---
  
---

# 基础

![image-20240304212301044](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240304212301044.png)

**打开mysql方式**

- **搜索命令提示符（cmd）**

'net start mysql80'

![image-20240304214959928](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240304214959928.png)

通过全局跳到path环境变量再输入

和cmd有一些差别

命令提示符然后管理员运行

- 用cmd命令


![image-20240304215654473](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240304215654473.png)

注意：环境变量配置是系统配置，然后变量名为path，设置成其他的都不管用

`mysql -u root -p`

-u接口、-p密码



**下载安装**

![image-20240305100857449](C:\Users\hxd15\Desktop\Repository\GithubRepository\MySQL_LearningNote\assets\image-20240305100857449.png)



mysql语言分类

![image-20240305101840442](C:\Users\hxd15\Desktop\Repository\GithubRepository\MySQL_LearningNote\assets\image-20240305101840442.png)



## DDL

### **数据库操作**

`查询`

```mysql
show databases;

select database();
```

`创建`

create database (if not exists) `test`;

create schema ……

`删除`

drop database (if exists) `test`;

`使用`

use `test`;



### **表操作**

- **查询**

show tables;

desc  `stuInfo`;

show create table `test`;	查询建表语句

- **创建**

```mysql
create table stuInfo(
	name varchar(10) comment '姓名',
	age int comment '年龄',
	sno varchar(15) comment '学号'
)comment '学生信息表'
```

- **修改**

添加字段

```mysql
-- 默认最后一排
alter table test add address varchar(20)
comment '地址';

-- 指定位置
alter table test add address varchar(20) after name;
alter table test add address varchar(20) first;
```

修改类型

```mysql
alter table test modify age varchar(3);
```

修改字段名和类型

```mysql
alter table test change address tel varchar(15) comment'电话号码';
```





删除字段

```mysql
alter table test drop tel;
```

修改表名

```mysql
alter table rename to stuInfo;
```

- 删除

删除表

```mysql
drop table (if exists) test;
```

删除指定表并重新创建该表

```mysql
truncate table test; # 数据全部丢失
```



移动字段

```mysql
-- 修改字段到第一列
alter table tb_emp modify Name varchar(25) FIRST;

-- 移动到某个字段后一列
alter table tb_emp modify DeptId int(11) AFTER Salary;

--语法规则为： ALTER TABLE 表名 MODIFY 字段1 数据类型 FIRST|AFTER 字段2; 。
```



删除表的外键约束

```mysql
alter table tb_emp drop foreign key emp_dept;
```



数据库名区分大小写





desc 描述

comment  v、评论，n、解释，评论









**字符串类型**

text blob char varchar

char（10)   最大长度 定长字符串 占用空间固定10 

varchar(10)  占用空间取决具体

性能上char高

varchar需要根据内容计算占用空间

**时间类型**

date

time





![image-20240305110406103](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240305110406103.png)

```mysql
create table employee(
	id varchar(10) comment '编号',
	workno varchar(15) comment '员工工号',
	name varchar(10) comment '员工姓名',
	gender char(1) comment '性别',
	age tinyint unsigned comment '年龄',
	idcard char(18) comment '身份证',
	entrydate date comment '入职时间'
)comment '员工信息';
```

` ` `符号是转义符号避免关键字冲突











![image-20240305112946191](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240305112946191.png)





## DML

### 添加数据

**指定数段添加数据**

```mysql
insert into employee(name,tel,address) values('张三','156789456','湖北武汉');
```

字符串，日期都要用‘ ’

- **添加数据**

```mysql
insert into employee values('张三','156789456','湖北武汉',18,'1');
```

- **批量添加数据**

```mysql
insert into employee (name, tel, address) values('张三', '789456' ,'湖北武汉'),('李四', '123456','北京');

insert into employee values('李四','8954612','北京', 19, '1'),('张三','156789456','湖北武汉',18,'2');
```

此处查询存储数据情况语句

```mysql
select * from employee;
```



---



### 修改数据

修改数据默认全修改，如果不加 

- 条件修改

```mysql
update employee set name = '李四' where id = 1;
```

- 全部修改

```mysql
update employee set entryDate = '2024-3-15';
```



---



### 删除数据

修改同理

- 条件删除

```mysql
delete from employee where gender = '女';
```

删除性别为女的信息

- 删除所有

```mysql
delete from employee;
```

删除数据至少为一行

如果需要删除某一个字段的值用update修改为NULL





















---



## DQL

### 基本语法

```mysql
SELECT
 字段列表
FROM
 表名列表
WHERE
 条件列表
GROUP BY
 分组字段列表
HAVING
 分组后条件列表
ORDER BY
 排序字段列表
LIMIT
 分页参数
```



### 基础查询

查询数据，起别名是查询出来的数据顶端有项目名字，方便查看

去除重复记录，查询的数据有重复的不显示

可以将查询进行组合

```mysql
select id,name from employee;

-- 全部查询，可以将字段全列出来
select * from employee;
select id,name,workno,workaddress … from employee;

-- 字段设置别名
SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;
SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;

select name as '姓名' from employee;

-- 去除重复
select distinct workaddress from employee;
```

正常查询结果如图，起别名后name会变成  姓名

![image-20240315150059861](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240315150059861.png)



### 条件查询

`!=  <>`		不等于

between …… and ……    闭区间

in …… 取in中的某个字段

**like	_匹配单个字符串，%匹配任意字符串**

is null



and	&&

or		||

not		!

```mysql
-- like
-- 查询姓名为两个字符
select * from emp where name like '__';

-- 查询身份证号最后一位是x
select * from emp where name like '%x';
select * from emp where name like '_______________x';
```





### 聚合函数

```mysql
-- count sum
-- max min avg
```

NULL值不参与计算，函数不能在where中使用

```mysql
select count (*) from employee; -- 统计记录数

select count(idcard) from employee; -- 统计不能null的idcard数

select count(1) from employee;
```

```mysql
# 统计西安地区工作人员年龄之和
select sum(age) from employee where address = '西安';
```



---

### 分组查询

`group by    having  `

```mysql
-- 根据性别分组统计男性员工和女性员工数量
select count(*) from employee group by gender;

-- 根据性别分组统计男性员工和女性员工的平均年龄
select avg(age) from employee group by gender;

-- 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址

select workaddress,count(*) from employee where age<45 group by workaddress having count(*) >= 3;

-- 别名写法
select workaddress,count(*) [as] address_count from emp where age<45 group by workaddress having address_count >3;

-- 可省略

```



### 排序查询

`order by`



```mysql
-- asc 升序
-- desc 降序

-- 根据年龄对公司的员工进行升序排序
select * from emp order by age asc;
-- 根据入职时间, 对员工进行降序排序
select * from emp order by entrydate desc;

-- 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序
select * from emp order by age asc,entrydate desc;
```



---

### 分页查询

`select * from emp limit ……`

`SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;`

```mysql
-- 查询第一页（索引为0）
select * from emp limit 0,5;
select * from emp limit 5;

-- 查询第二页数据，每页5个
select * from emp limit 5,5;

```





### 案例

```mysql
-- 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数

-- 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按
入职时间降序排序。
select name,age from emp where age<=35 order by age asc,entrydate desc;

-- 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，
年龄相同按入职时间升序排序
select * from emp where age>=20 && age<=40 order by age asc,entrydate asc limit 0,5
```



### 执行顺序

![image-20240319090055182](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240319090055182.png)



```mysql
select e.name ename , e.age eage from emp e where e.age > 15 order by eage asc;
```







---

## DCL

 查询用户

```mysql
use mysql;
select * from mysql.user;
```

创建用户

```mysql
create user 'itcast'@'主机名' identified by '密码';
```

修改用户密码

```mysql
alter user 'itcase'@'主机名'identified with mysql_native_password by '新密码';
-- 本地密码处理方式
```

删除用户

```mysql
drop user'用户名'@'主机名'
```

主机名可以用%来进行匹配，表示任意主机



**权限管理**

查询权限

```mysql
show grants for '用户名'@'主机';
```

授予权限

```mysql
grant 权限列表 on 数据库名.表名 to '用户名'@'主机'
```

撤销权限

```mysql
revoke 权限列表 on 数据库名.表名 from '用户名'@'主机'
```



## 函数

### 字符串函数

![image-20240319102655791](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240319102655791.png)

```mysql
select CONCAT('hello',' ','world','!');

select LOWER('HELLO');
select UPPER('hello');

-- 字符串填充注意
select LPAD('str',5,'abc');
select RPAD('str',5,'abcdef');

select TRIM('  1231234sffda  ');

-- 截取字符串 索引是从1开始的
select SUBSTRING('123456abcdef',2,5);
```

![image-20240326101410919](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326101410919.png)



----



### 数值函数

![image-20240319102716959](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240319102716959.png)

```mysql
select CEIL(1.3);
select FLOOR(1.3);
select MOD(5,2);
select RAND();
select ROUND(4.5893423,3);
```



---



### 日期函数

![image-20240326095816051](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326095816051.png)

```mysql
select CURDATE();	# 日期
select CURTIME(); 	# 时间
select NOW(); 		# 日期+时间

select YEAR(NOW());
select MONTH(NOW());
select DAY(NOW());

select DATE_ADD(NOW(),INTERVAL 20 YEAR);

# 前-后
select DATEDIFF('2023-3-26','2033-5-15');
```



---



### 流程函数

基本函数

![image-20240326102922208](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326102922208.png)

应用

```mysql
select IF(true,'ok','no');
select IF(false,'ok','no');

select IFNULL('not null','null');
select IFNULL(null,'null');
select IFNULL('','Default'); # 第一空非NULL

select name,
( CASE workaddress WHEN '北京' then '一线城市' WHEN '上海' then '一线城市' else '二线城市'end ) '工作地址'
from emp;

select id,name,
( CASE WHEN age>=20 && age<=30 then'年轻' WHEN age>30 then '中年' end )
from emp;
```



---



## 约束

![image-20240326104607136](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326104607136.png)

`AUTO_INCREMENT`每次添加数据自动加1，id等较多使用

```mysql
create table tb_user(
	id int primary key auto_increment, # 顺序可调
	name varchar(10) not null unique,
    age int check(age > 0 && age <= 120),
    status char(1) default '1',
    gender char(1)
);
```

![image-20240326160842217](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326160842217.png)



**外键约束**

![image-20240326161028937](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326161028937.png)

删除dept部门表，但是员工表对应的部门编号仍然存在，员工表对应的数据本应该也被删除，为了保证数据表的完整性，此时需添加外键约束

```mysql
# 表内添加外键
CREATE TABLE 表名(
 字段名 数据类型,
 ...
 [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) 
);

# 表外添加外键
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) 
REFERENCES 主表 (主表列名) ;
```



**外键案例**

```mysql
# 数据准备
create table dept(
 id int auto_increment comment 'ID' primary key,
 name varchar(50) not null comment '部门名称'
)comment '部门表';

INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, 
'销售部'), (5, '总经办');

create table dept_emp(
 id int auto_increment comment 'ID' primary key,
 name varchar(50) not null comment '姓名',
 age int comment '年龄',
 job varchar(20) comment '职位',
 salary int comment '薪资',
 entrydate date comment '入职时间',
 managerid int comment '直属领导ID',
 dept_id int comment '部门ID'
)comment '员工表';

INSERT INTO dept_emp (id, name, age, job,salary, entrydate, managerid, dept_id) 
VALUES
 (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
 (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
 (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
 (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
 (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1);

```

```Mysql
# 给员工表添加部门外键
alter table dept_emp add constraint fk_dept_emp_dept_id foreign key (dept_id) references dept(id);
```



添加外键后，删除父表会产生约束，删除子表没事

![image-20240326194210427](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326194210427.png)



**删除外键**

```mysql
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```

删除/更新 父表 

![image-20240326195135306](C:\Users\hxd15\AppData\Roaming\Typora\typora-user-images\image-20240326195135306.png)



```mysql
# 用法
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;

alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null ;
```





---

## 多表查询

数据准备

```mysql
create table dept(
 id int auto_increment comment 'ID' primary key,
 name varchar(50) not null comment '部门名称'
)comment '部门表';
INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, 
'销售部'), (5, '总经办'), (6, '人事部');

create table emp(
 id int auto_increment comment 'ID' primary key,
 name varchar(50) not null comment '姓名',
 age int comment '年龄',
 job varchar(20) comment '职位',
 salary int comment '薪资',
 entrydate date comment '入职时间',
 managerid int comment '直属领导ID',
 dept_id int comment '部门ID'
)comment '员工表';

alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);

INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) 
VALUES
 (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
 (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
 (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
 (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
 (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
 (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),
 (7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),
 (8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),
 (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),
 (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),
 (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),
 (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),
 (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),
 (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),
 (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),
 (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),
 (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);
```



```mysql
# 正常多表查询出现的笛卡尔积需要消除
select * from dept_emp,dept;
# 出现的数据远大于数据表实际存储
```

![image-20240511142138217](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511142138217.png)



---



### 内连接

```mysql
# 隐式内连
select * from dept_emp ,dept where dept_emp.dept_id = dept.id;

# 显示内连
select * from dept_emp [inner] join dept on dept_id = dept.id;
```

### 外连接

```mysql
# 左外
select e.* ,d.name '部门' from dept_emp e left [outer] join dept d on e.dept_id = d.id;

# 右外
select d.name ,e.* from dept d right outer join dept_emp e on d.id = e.dept_id;

# 注意书写顺序，即可达到右外=左外
```

内连接和外连接区别在于，内连接不会显示**交集中NULL的内容**，外连接会显示

```mysql
select e.*, d.name from emp e join dept d on e.dept_id = d.id;

select e.*, d.name from emp e left join dept d on e.dept_id = d.id;
```

**内连接查询**

![image-20240511143859189](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511143859189.png)

**外连接查询**

![image-20240511144003266](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511144003266.png)



**左外右外连接理解**

```
# 先姓名后部门  左外
select e.* ,d.name from emp e left outer join dept d on e.dept_id = d.id;
# 先姓名后部门  右外
select e.* ,d.name from dept d right outer join emp e on d.id = e.dept_id;
# 先部门后姓名  左外
select d.name,e.* from dept d left outer join emp e on d.id = e.dept_id;
# 会将所有部门显示出来
```

前两种情况对应查询结果

人事部没有显示

![image-20240513152804466](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240513152804466.png)



部门在前，将所有部门显示

![image-20240513152919822](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240513152919822.png)

---



### 自连接

自己连接自己，就是把一张表连接查询多次

给同一张表设置多次别名

```mysql
# 查询员工和所属领导的姓名
select e1.name ,e2.name from dept_emp e1 , dept_emp e2 where e1.managerid = e2.id;

# 查询所有员工和所属领导姓名，没有领导也要查询出来
select e1.name '员工',e2.name '领导' from dept_emp e1 left outer join dept_emp e2 on e1.managerid = e2.id;
# 外连接区别内连接的特点
```



---



### 联合连接

把多次查询的结果联合起来

```mysql
# 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.
# 用多条件判断可以达到同样的效果
select * from emp where salary < 5000
union all    # all去掉 为去重
select * from emp where age > 50;
```

![image-20240511154420913](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511154420913.png)

有重复的，去掉这种情况，如下即可

```mysql
select * from emp where salary < 5000
union
select * from emp where age > 50;
```

注：必须保证两个表查询结果一致，否则出错

![image-20240511154719249](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511154719249.png)



---



### 子查询

#### 标量子查询

子查询返回的结果是**单个值**（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 

常用的操作符：= 、<> 、> 、>=、 < 、<=

```mysql
# 根据销售部部门id查询该部门所有员工姓名、年龄、性别
select name,age,sex from emp where dept_id = (select id from emp_dept where dept = '销售部');

# 查询在张三之后入职的员工姓名，年龄，电话
select name,age,tel from emp where entryDate > (select entryDate from emp where name = '张三');
```



---

#### 列子查询

子查询返回的结果是一列（多行）

![image-20240511123239548](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240511123239548.png)

**操作符** 

IN                   在指定的集合范围之内，多选一 

NOT IN         不在指定的集合范围之内

 ANY             子查询返回列表中，有任意一个满足即可 

SOME           与ANY等同，使用SOME的地方都可以使用ANY 

ALL               子查询返回列表的所有值都必须满足

可以与比较操作符搭配使用

```mysql
# 查询部门为销售部和市场部的所有员工的信息
select * from emp where id_dept IN (select id from emp_dept where dpet = '销售部' or dept = '市场部');

# 查询比财务部所有人工资都高的员工信息
select * from emp where salary > ALL(select salary from emp where id_dept = (select id from emp_dept where dept = '财务部'));
# 分解：查询财务部所有人工资  查询比该所有人工资都高的员工信息

# 查询比研发部其中任意一人工资都高的员工信息
select * from emp where salary > ANY(select salary from emp where id_dept = (select id from emp_dept where dept = '研发部'));
```



---

#### 行子查询

返回的结果是一行（多列）

常用操作符：= 、<> 、IN 、NOT IN

```mysql
# 查询与张三工资相同且直属领导相同的员工信息
select * from emp where (salary,manageId) = (select salary,manageId from emp where name = '张三');
```



---

#### 表子查询

返回的结果是多行多列,可以当成表用

IN 常用

```mysql
# 查询与 张三，李四 的职位和薪资相同的员工信息
select * from emp where (job,salary) = (select job,salary from emp where name = '张三' or '李四');

# 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息
select e.*,d.dpet from (select * from emp where entryDate > '2006-01-01') e left outer join emp_dept d on e.id_dept = d.id;
```













## 事务

事务保持一个过程的原子性，即连续不可中断

```mysql
create table account(
	id int primary key AUTO_INCREMENT comment 'ID',
	name varchar(10) comment '姓名',
	money double(10,2) comment '余额'
) comment '账户表';

insert into account(name, money) VALUES ('张三',2000), ('李四',2000);
```









```
transaction
```







脏读



不可重复读



幻读

























# 进阶

数据库Linux版本下载

[MySQL :: Download MySQL Community Server (Archived Versions)](https://downloads.mysql.com/archives/community/)

![image-20240416095015710](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416095015710.png)

打开finalshell，将下载文件上传，然后进行解压

![image-20240416095052027](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416095052027.png)



1.  创建一个文件夹 `mkdir mysql`
2. 输入指令解压`tar -xvf mysql-8.2.0-1.el9.x86_64.rpm-bundle.tar -C mysql` 并将压缩包解压到mysql下



存储引擎









## 索引

主键索引					primary

唯一索引					unique

常规索引					无

全文索引					fulltext



**聚集索引**

- 存在主键，主键为聚集索引
- 不存在主键，取第一个唯一索引
- 二者均无，系统自动生成rowid作为隐藏索引

**二级索引**

查找二级索引时，会根据二级索引查到主键值然后再到聚集索引中进行回表聚集索引查询，即回表查询



### 索引语法

```mysql
# 创建索引
CREATE [UNIQUE | FULLTEXT] INDEX idex_name ON table_name(idex_col_name,……);

create index index_user_name on tb_user2(name);
---------
# 查看索引
SHOW INDEX FROM table_name ;

show index from tb_user2;
---------
# 删除索引
DROP INDEX index_name ON table_name ;

drop index index_user_nmae on tb_user2;
```



##### 试验表

```mysql
create table tb_user2(
 id int primary key auto_increment comment '主键',
 name varchar(50) not null comment '用户名',
 phone varchar(11) not null comment '手机号',
 email varchar(100) comment '邮箱',
 profession varchar(11) comment '专业',
 age tinyint unsigned comment '年龄',
 gender char(1) comment '性别 , 1: 男, 2: 女',
 status char(1) comment '状态',
 createtime datetime comment '创建时间'
) comment '系统用户表';
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('吕布', '17799990000', 'lvbu666@163.com', '软件工程', 23, '1', 
'6', '2001-02-02 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('曹操', '17799990001', 'caocao666@qq.com', '通讯工程', 33, 
'1', '0', '2001-03-05 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('赵云', '17799990002', '17799990@139.com', '英语', 34, '1', 
'2', '2002-03-02 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('孙悟空', '17799990003', '17799990@sina.com', '工程造价', 54, 
'1', '0', '2001-07-02 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('花木兰', '17799990004', '19980729@sina.com', '软件工程', 23, 
'2', '1', '2001-04-22 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('大乔', '17799990005', 'daqiao666@sina.com', '舞蹈', 22, '2', 
'0', '2001-02-07 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('露娜', '17799990006', 'luna_love@sina.com', '应用数学', 24, 
'2', '0', '2001-02-08 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('程咬金', '17799990007', 'chengyaojin@163.com', '化工', 38, 
'1', '5', '2001-05-23 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('项羽', '17799990008', 'xiaoyu666@qq.com', '金属材料', 43, 
'1', '0', '2001-09-18 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('白起', '17799990009', 'baiqi666@sina.com', '机械工程及其自动
化', 27, '1', '2', '2001-08-16 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('韩信', '17799990010', 'hanxin520@163.com', '无机非金属材料工
程', 27, '1', '0', '2001-06-12 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('荆轲', '17799990011', 'jingke123@163.com', '会计', 29, '1', 
'0', '2001-05-11 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('兰陵王', '17799990012', 'lanlinwang666@126.com', '工程造价', 
44, '1', '1', '2001-04-09 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('狂铁', '17799990013', 'kuangtie@sina.com', '应用数学', 43, 
'1', '2', '2001-04-10 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('貂蝉', '17799990014', '84958948374@qq.com', '软件工程', 40, 
'2', '3', '2001-02-12 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('妲己', '17799990015', '2783238293@qq.com', '软件工程', 31, 
'2', '0', '2001-01-30 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('芈月', '17799990016', 'xiaomin2001@sina.com', '工业经济', 35, 
'2', '0', '2000-05-03 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('嬴政', '17799990017', '8839434342@qq.com', '化工', 38, '1', 
'1', '2001-08-08 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('狄仁杰', '17799990018', 'jujiamlm8166@163.com', '国际贸易', 
30, '1', '0', '2007-03-12 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('安琪拉', '17799990019', 'jdodm1h@126.com', '城市规划', 51, 
'2', '0', '2001-08-15 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('典韦', '17799990020', 'ycaunanjian@163.com', '城市规划', 52, 
'1', '2', '2000-04-12 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('廉颇', '17799990021', 'lianpo321@126.com', '土木工程', 19, 
'1', '3', '2002-07-18 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('后羿', '17799990022', 'altycj2000@139.com', '城市园林', 20, 
'1', '0', '2002-03-10 00:00:00');
INSERT INTO tb_user2 (name, phone, email, profession, age, gender, status, 
createtime) VALUES ('姜子牙', '17799990023', '37483844@qq.com', '工程造价', 29, 
'1', '4', '2003-05-26 00:00:00');
```



##### **需求**

A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。

B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。 

C. 为profession、age、status创建联合索引。 

D. 为email建立合适的索引来提升查询效率。  

完成上述的需求之后，我们再查看tb_user表的所有的索引数据。



```mysql
create index index_user_name on tb_user2(name);

create unique index index_user_phone on tb_user2(phone);

create index index_user_pro_age_sta on tb_user2(profession,age,status);

create index index_email on tb_user2(email);

#删除姓名索引
drop index index_name on tb_user2;
```



---



### SQL性能分析

#### SQL执行频率

可以通过`show [session|global] status`查询数据库各操作频率（增删改查）注：需要字符匹配，否则会出现其他非常多数据

![image-20240416144453628](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416144453628.png)



```mysql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______'; # 7
```

![image-20240416144555981](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416144555981.png)





#### 慢查询日志

慢日志查询可以看到所有执行SQL时间超过指定参数的日志（秒）

默认不开启 slow_query_log = 0;

通过命令`show variables like 'slow_query_log'` 查看慢日志是否开启

![image-20240416145326407](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416145326407.png)

---

MySQL的配置文件（/etc/my.cnf）中将信息修改，如下

`vi /etc/my.cnf`

```mysql
# 开启MySQL慢日志查询开关
slow_query_log=1

# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

然后系统会生成一个文件/var/lib/mysql/localhost-slow.log 记录信息

退出重启`systemctl restart mysqld`



#### profile详情

profile可以帮助我们知道SQL语句执行时，时间具体都耗费到哪些地方

通过`select @@have_profiling` 查看profile是否开启

`set profiling = 1` 开启(需要权限)



```mysql
-- 查看每一条SQL的耗时基本情况
show profiles;

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```



![image-20240416152152557](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416152152557.png)





![image-20240416152341534](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416152341534.png)





![image-20240416152407183](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416152407183.png)



#### explain

通过命令查看Mysql如何执行select语句，以及性能等

```mysql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```



![image-20240416163024745](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416163024745.png)



主键索引查询会出现const，如果不是主键则会出现ref

![image-20240416161639896](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416161639896.png)



 

主要关注

![image-20240416162140609](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240416162140609.png)













### 索引使用

#### 验证索引效率

```mysql
select * from tb_user where id = 1 \G; # 将信息竖向展示

select * from tb_user where sn = "10000000";
#创建索引
create index idx_tb_user_sn on tb_user(sn);
select * from tb_user where sn = "10000000";
```

---



#### 最左前缀法则

- 查询使用联合索引，如果跳过了最左边（第一列），则查询不再使用索引


![image-20240423103517983](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240423103517983.png)



- 联合索引，如果最左列存在，但是**中间列不存在**，不论后面列是否存在，后面的索引字段全部失效

![image-20240423104037398](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240423104037398.png)



注意：查询where字段间顺序改变不影响索引查询，只要保证最左列存在即可

---



#### 范围查询

当用符号 “ <> ” 时，符号右边字段并没有走索引

![image-20240423104729690](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240423104729690.png)



---



#### 索引失效情况

- 索引列运算

用函数进行运算等，会导致索引失效

```mysql
explain select * from tb_user where substring(phone,10,2) = '15';
```



- 字符串不加引号

虽然都可以进行查询，但是，没有添加引号，索引失效

```mysql
explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';

explain select * from tb_user where profession = '软件工程' and age = 31 and status = 0;
```



- 模糊查询

尾部模糊，索引有效；头部模糊，索引失效

```mysql
explain select * from tb_user where profession like '软件%';

explain select * from tb_user where profession like '%工程';

explain select * from tb_user where profession like '%工%';
```



- or连接条件

or左右两个字段都有索引，索引查询才会生效（可以不联合）

```mysql
explain select * from tb_user where id = 10 or age = 23;

explain select * from tb_user where phone = '17799990017' or age = 23;

#id phone有索引 age无索引
```



- 数据分布影响

MySQL评估索引查询和普通查询哪个更快

一般，百万级数据以上用索引查询

走全表扫描还是索引看表中的数据在某条件下的分布情况

索引 是用来查询少量情况

```mysql
select * from tb_user where phone >= '17799990005';

select * from tb_user where phone >= '17799990015';
```

在1句范围数据更大，所以一句采用的全表扫描，二句采用索引













## 视图/存储过程/触发器

### 视图

视图通俗是企业想展示给你看的，数据库存储的数据有很多，但是也有很多是不能对外公开的，做项目的过程就通过视图这个媒介达到这种效果

视图也可以保证数据库表结构字段的隐私安全等

```mysql
create or replace view stu_v_1 as select id studentName as name from student where id <= 10;
```



用户只能更改视图中展现的数据，并且不允许用户去修改表的字段，更加安全

#### 基本语法

```mysql
#  视图创建
create [or replace] view 视图名 as select …… from …… [with [cascaded | local] check option]

# 视图查询
show create view 视图名   # 查看创建语句
select * from 视图名      # 查看数据
 
 # 视图修改
 # 方式一
 create or replace view 视图名 as select …… from …… [with [cascaded | local] check option]  # 重新更新视图名
 # 方式二
 alter view 视图名 as select …… from …… [with [cascaded | local] check option]     #alter 声明修改表类似
 
 # 视图删除
drop view [if exists] 视图名 
```



```bash
视图创建
create or replace view stu_v_1 as select name,age from student where id <= 10;

视图查询
show create view stu_v_1;

select * from stu_v_1 where id <= 10;

视图修改
# 方式一
create or replace view stu_v_1 as select name,age,tel from student where id >= 20;

alter view stu_v_1 as select name,age,tel from student where id >= 20;


视图删除
drop view if exists stu_v_1;
```



---

#### 检查选项

用where时，不符合条件的数据可以插入表，但是**视图不会展示**

检查选项，**避免插入**不符合 条件数据，即数据不会插入表

cascaded 		联结，检查选项对当前视图作用 且 前无检查选项的视图默认检查

local                  本地检查，检查选项仅对当前视图作用



mysql可以根据一个视图创建另一个视图，并且两个视图的限制条件会结合起来

**cascaded特点**

![image-20240512123012644](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240512123012644.png)

前视图没有添加检查语句，但是后视图基于前视图，用了cascaded，则会给前视图默认添加检查选项，添加数据时，如果id>20会报错



**local特点**

![image-20240512122953680](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240512122953680.png)



---

#### 视图更新

视图创立后，插入数据，有些 “客观” 数据不允许对其进行修改

A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） 

B. DISTINCT

 C. GROUP BY 

D. HAVING 

E. UNION 或者 UNION ALL



```mysql
create view stu_v_1 as select count(*) from student;
# "客观"  数据不允许修改
insert into stu_v_1 values(10);   # 插入其他数字
```



---

#### 视图总

##### 视图理解1

创建视图，展示表，视图被算入其中，所以命名要注意规范

视图是基于表的数据

![image-20240512220020789](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240512220020789.png)

用第一种方式修改视图

```mysql
create or repalce view emp_v_1 as select id,name,age from emp where id <= 18;

# 插入张三相关信息 到 emp表
insert into emp values(4,'李四',20,'销售','2000','2020-01-02',14,4);

# 再次查询
select * from emp_v_1;
```

![image-20240512220559895](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240512220559895.png)



---

##### 视图理解2

在刚刚基础上添加检查选

```mysql
create or repalce view emp_v_2 as select id,naem,age from emp_v_1 where id >= 10 with cascaded check option

# 插入数据到 emp表
insert into emp values(19,'李四',20,'销售','2000','2020-01-02',14,4);
# id为19 ，超过emp_v_1 范围 
```

直接插入表不符条件数据不受视图检查选项影响，视图不会将其展示。

如果是将数据通过插入到视图 插入到emp表，则会报错

![image-20240512221356981](C:\Users\hxd15\Desktop\Repository\GithubRepository\assets\image-20240512221356981.png)













### 存储过程

介绍



基本语法



变量

系统变量

用户定义变量

局部变量



if

参数

case

while

repeat

loop

游标

条件处理程序









触发器

